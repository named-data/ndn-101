{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Named Data Networking","text":"<p>Named Data Networking (NDN)<sup>1</sup> is a future Internet architecture inspired by years of research into network usage and a growing awareness of unsolved problems in the contemporary protocols. Many of these problems arise due to the fundamental mismatch between the data-centric usage of the Internet and the host-centric nature of IP. NDN is designed as a data-centric replacement of the TCP/IP architecture, thus overcoming this mismatch by replacing the network layer itself. The NDN project is now a collaborative effort of a large community of researchers at more than a dozen institutions.</p> <p>NDN retains the Internet's hourglass architecture but evolves the thin waist to allow the creation of completely general distribution networks. The core element of this evolution is removing the restriction that packets can only identify communication endpoints. As far as the network is concerned, the identifier in an NDN packet can be anything \u2014 an endpoint, a chunk of movie or book, a command to turn on some lights, etc. This conceptually simple change allows NDN networks to use almost all of the Internet\u2019s well understood and well tested engineering properties to efficiently solve not only communication problems but also digital distribution and control problems.</p> <p>A more detailed discussion can be found at the website of the NDN project (named-data.net)</p> <p>The design of NDN naturally leads to several advantages over IP and IP-based protocols. Some of these are briefly described below.</p> <ul> <li> <p>Data-Centric Security: NDN provides data-centric security<sup>2</sup> where it secures data directly rather than relying on securing the channels that transmit the data. Each packet of data carries a cryptographic signature that binds the name, contents and the identity of the producer of the data.</p> </li> <li> <p>Privacy: NDN provides privacy by allowing consumers to retrieve data without needing to expose their identity to the network. This is in contrast to IP where the source and destination addresses are exposed in every packet.</p> </li> <li> <p>Name-based Forwarding: NDN packets are routed and forwarded using their names. This allows NDN routers to make forwarding decisions based on application semantics rather than just network addresses. This also directly provides support for anycast for applications.</p> </li> <li> <p>Intelligent Data Plane: NDN utilizes a stateful forwarding plane where forwarders track the requests and responses of data. This allows NDN to support a wide range of advanced features such as adaptive and multipath forwarding, and provides DDoS protection<sup>3</sup> and congestion control<sup>4</sup> at the network layer.</p> </li> <li> <p>Multicast and Caching: The stateful forwarding plane allows for aggregation of requests and responses, which enables efficient multicast of all Data packets. Since NDN packets are individually secured and do not rely on channel security, data is also securely cached at every forwarder in the network, creating a massive distributed cache.</p> </li> </ul> <p>The NDN project also maintains a large open source code base, with NDN forwarders, debugging tools and libraries available in multiple languages including C++, Python, Go, TypeScript etc. Most of this code is available at GitHub.</p> <ol> <li> <p>Zhang, L. et al. 2014. Named Data Networking. ACM SIGCOMM Computer Communication Review (CCR). 44, 3 (2014), 66\u201373.\u00a0\u21a9</p> </li> <li> <p>Zhang, Z. et al. 2018. An overview of security support in named data networking. IEEE Communications Magazine. 56, 11 (2018), 62\u201368.\u00a0\u21a9</p> </li> <li> <p>Gasti, P. et al. 2013. DoS and DDoS in named data networking. 2013 22nd international conference on computer communication and networks (ICCCN) (2013), 1\u20137.\u00a0\u21a9</p> </li> <li> <p>Song, S. and Zhang, L. 2022. Effective NDN congestion control based on queue size feedback. Proceedings of the 9th ACM conference on information-centric networking (New York, NY, USA, 2022), 11\u201321.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/","title":"Getting Started with NDN","text":"<p>This page will guide you through the process of installing the basic tools needed to start using and developing NDN applications.</p>"},{"location":"getting-started/#packet-forwarder","title":"Packet Forwarder","text":"<p>To begin, you will need to first install an NDN Packet Forwarder on your computer. There are several implementations of forwarders, the most popular of which are:</p> <ul> <li>NFD<sup>1</sup>, the reference implementation (C++)</li> <li>NDNd<sup>2</sup>, a multithreaded implementation (Golang)</li> <li>NDN-DPDK<sup>3</sup>, a high-performance implementation (C)</li> <li>NDN-Lite<sup>4</sup>, an IoT implementation (C)</li> </ul> <p>What is the role of the forwarder?</p> <p>The forwarder is the NDN equivalent of an IP \"router\", and runs on each node in the network. It is responsible for forwarding NDN packets between nodes, including functions of Data multicast and caching.</p>"},{"location":"getting-started/#client-library","title":"Client Library","text":"<p>Next, you will need to install a client library of your choice to interact with the NDN network. Depending on the library, you will need the corresponding compilers / interpreters / build tools.</p> <ul> <li>ndn-cxx (C++) [Docs, API]</li> <li>NDNd (Golang) [API]</li> <li>python-ndn (Python) [Docs]</li> <li>NDNts (TypeScript) [Docs]</li> <li>NDN-Lite (C, IoT) [Docs, API]</li> <li>esp8266ndn (Arduino) [API]</li> </ul> <p>What does the client library do?</p> <p>The client library provides the NDN equivalent of a TCP/IP \"socket\", and runs inside each application. It is responsible for encoding and decoding NDN packets, and sending / receiving them to / from NFD.</p> <p>Once you have installed NFD and a client library, you need to start NFD on your local development machine. You are now ready to start developing NDN applications!</p> <p>Contributing to the NDN codebase</p> <p>The NDN codebase is free and open-source software, and most of it is available on GitHub. If you are interested in contributing, make sure you read this guide and the code of conduct first.</p>"},{"location":"getting-started/#debugging-tools","title":"Debugging Tools","text":"<p>The ndn-tools package is highly recommended and contains several tools for developing and debugging NDN applications. The NDNd package also offers many of these tools with prebuilt binaries available.</p> <ul> <li>peek: transmit a single Interest/Data packet between a consumer and a producer.</li> <li>get and serve: segmented file transfer between a consumer and a producer.</li> <li>ping: test reachability between two NDN nodes</li> <li>dump: capture and analyze live traffic on an NDN network</li> <li>dissect: inspect the TLV structure of an NDN packet</li> <li>dissect-wireshark: Wireshark extension to inspect the TLV structure of NDN packets</li> </ul> <p>Ping test</p> <p>You can run a simple test for your local NDN forwarder by using the ndn-tools or NDNd packages to start a ping server and client on the same machine. These will then communicate by connecting to the forwarder over a unix socket.</p> ndn-toolsNDNd <pre><code>ndnpingserver /my/nfd/test &amp;\nndnping /my/nfd/test\n</code></pre> <pre><code>ndnd pingserver /my/ndnd/test &amp;\nndnd ping /my/ndnd/test\n</code></pre>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<p>If you have any questions about NDN or the code base, we encourage you to reach out to the community for help. Some options include,</p> <ul> <li>Ask a question at the most appropriate mailing list.</li> <li>File an issue at the relevant GitHub repository or Redmine.</li> <li>(If applicable) reach out to the authors of the paper that introduced the software.</li> </ul> <ol> <li> <p>Afanasyev, A. et al. 2014. NFD developer\u2019s guide. Dept. Comput. Sci., Univ. California, Los Angeles, Los Angeles, CA, USA, Tech. Rep. NDN-0021. 29, (2014), 31.\u00a0\u21a9</p> </li> <li> <p>Newberry, E. et al. 2021. YaNFD: Yet another named data networking forwarding daemon. Proceedings of the 8th ACM conference on information-centric networking (New York, NY, USA, 2021), 30\u201341.\u00a0\u21a9</p> </li> <li> <p>Shi, J. et al. 2020. NDN-DPDK: NDN forwarding at 100 gbps on commodity hardware. Proceedings of the 7th ACM conference on information-centric networking (New York, NY, USA, 2020), 30\u201340.\u00a0\u21a9</p> </li> <li> <p>Zhang, Z. et al. 2018. NDNoT: A framework for named data network of things. Proceedings of the 5th ACM conference on information-centric networking (New York, NY, USA, 2018), 200\u2013201.\u00a0\u21a9</p> </li> </ol>"},{"location":"storage/","title":"Storage","text":"<p>Persistent storage is a key component of application functionality. In the NDN philosophy, highly available storage is provided as part of the network infrastructure. This allows applications to store data in the network, and to retrieve it from the network, without needing to rely on a separate storage service.</p> <p>Generally speaking, there are three kinds of storage services in NDN. We describe each of these in further detail below.</p> <ul> <li>Application Storage: storage used by a particular application instance.</li> <li>Data Repository: a persistent general-purpose storage deployed in the network.</li> <li>Content Store: a passive cache configured in all NDN forwarders.</li> </ul> <p>General purpose storage</p> <p>By design, NDN data stores are typically not application-specific, being provided as a service by the network infrastructure. This is in contrast to traditional cloud storage services, which are provided by third-party vendors and require applications to adapt to their specific APIs. Since data is secured independently of the transport and storage, the stored data is always secured at rest and in transit.</p>"},{"location":"storage/#application-storage","title":"Application Storage","text":"<p>Individual NDN applications typically require local storage for the data at a particular instance. This may include data that has been produced by the application, or data that has been fetched from the network. The application storage is typically managed by the application itself, and is not shared with other applications.</p> <p>NDN libraries provide APIs for applications to store and retrieve data from local storage using the name. The storage itself may be implemented using memory or disk, and may store either the raw Data packets or the application-specific data structures.</p> ndn-cxx <pre><code>#include &lt;cassert&gt;\n#include &lt;ndn-cxx/ims/in-memory-storage-persistent.hpp&gt;\n#include &lt;ndn-cxx/security/key-chain.hpp&gt;\n\nint main(int argc, char** argv)\n{\n    // Create an in-memory application-specific storage\n    ndn::InMemoryStoragePersistent ims;\n\n    // Create and sign a data packet\n    auto data = std::make_shared&lt;ndn::Data&gt;(\"/test/data\");\n    data-&gt;setContent(\"Hello, World!\");\n    ndn::KeyChain keyChain;\n    keyChain.sign(*data);\n\n    // Insert a data packet into the store\n    ims.insert(*data);\n\n    // Find a data packet in the store\n    ndn::Interest interest(\"/test/data\");\n    assert(ims.find(interest)-&gt;getName() == data-&gt;getName());\n}\n</code></pre>"},{"location":"storage/#data-repository","title":"Data Repository","text":"<p>Imagine the following scenario: an application uses some public online storage to store its data. To make sure the online storage stores the data faithfully, every uploaded file is signed. The application provider does not need to operate the storage, nor do they need to pay for it: the users will use their own quota and pay themselves. To make sure data are available in case when the storage is down, users also have local copies of their data.</p> <p>In this scenario, the role of the online storage plays a role similar to a Repo in NDN networks in some aspects but different in others.</p> <ul> <li>The similarities<ul> <li>General-purpose: the storage is not designed for specific application and not operated by application teams. The storage do not run application logic.</li> <li>Untrusted: the storage is not trusted in the application's trust domains. It has its own trust relationship with producers who upload data to it, but this is not related to the application. The storage is not allowed to produce any data for the application.</li> <li>Rendezvous point: when peers cannot be online simultaneously, the repo makes data available.</li> </ul> </li> <li>The differences<ul> <li>The cloud storage has its own API. However, in the NDN world, data fetching is done by stardard Interest-Data exchange. Data consumers will notice the existence of Repo, ideally.</li> <li>Different cloud providers typically cannot collaborate with each other, and the application developers have to pick some providers and adapt for them. NDN applications do not have to adapt for specific Repo providers.</li> </ul> </li> </ul>"},{"location":"storage/#content-store","title":"Content Store","text":"<p>The content store is an ephemeral cache in each NDN forwarder in the network, which stores the most recently or frequently requested data. Unlike the other storage types described above, the application does not exercise any control over the data stored in the content store. Further the content store does not provide any guarantess on cache eviction or availability, and thus should not be relied upon for long-term storage.</p> <p>Data Immutability</p> <p>Since any forwarder in the network may cache data for any duration of time, applications must not rely on a given Data packet eventually being unavailable. Each Data packet must be treated as immutable and potentially available forever, and thus names must not be reused.</p> <p>Clearing the content store</p> <p>During application development, the content store may lead to unexpected behavior, e.g. data that has not been produced yet may be available from a previous test run. In such situations, you may want to clear the cache using the <code>nfdc</code> command-line tool.</p> <pre><code>nfdc cs erase /&lt;prefix&gt;  # erase all cached data under a prefix\n</code></pre>"},{"location":"sync/","title":"Synchronization","text":"<p>This page is under construction.</p>"},{"location":"connectivity/building-networks/","title":"Building NDN Networks","text":"<p>Before running NDN applications, you may need to set up your own NDN network or connect to the existing global NDN testbed. This section describes the process of building your own network. A more detailed example for NDNd suitable for beginners can be found here.</p> <p>NDN applications interact with the network using an general purpose abstraction called faces. A face may, for instance, be backed an actual ethernet interface or it tunnel over a UDP or TCP connection. NDN forwarders, in turn, also connect to each other over faces, which may be either tunnels or physical links. Thus, building an NDN network consists of two steps:</p> <ol> <li>Configuring faces at each forwarder to each neighbor of that forwarder. This step is equivalent to physically plugging in cables on a traditional IP router.</li> <li>Configuring routes to data prefixes between forwarders. This step can be done either manually or using a routing protocol.</li> </ol> <p>The example below shows how to manually create an NDN face over a UDP tunnel between two NDN forwarders using the nfdc and NDNd CLI tools. Both nodes must already be running an NDN forwarder before this step.</p> ndn-cxxNDNd <pre><code># https://docs.named-data.net/NFD/24.07/manpages/nfdc-face.html\nnfdc face create remote udp://router.example.net\n</code></pre> <pre><code># https://github.com/named-data/ndnd/blob/main/docs/fw-control.md\nndnd fw face-create remote=udp://router.example.net\n</code></pre> <p>Once a face is created, you can use the same tool to add routes between the two forwarders and start transferring data.</p> ndn-cxxNDNd <pre><code># Add route for /example to remote\n# https://docs.named-data.net/NFD/24.07/manpages/nfdc-route.html\nnfdc route add prefix /example nexthop udp://router.example.net\n</code></pre> <pre><code># Add route for /example to remote\n# https://github.com/named-data/ndnd/blob/main/docs/fw-control.md\nndnd fw route-add prefix=/example face=udp://router.example.net\n</code></pre> <p>You can now start an NDN ping server on the example forwarder and the prefix would be reachable from the router creating the face.</p> ndn-cxxNDNd <pre><code># Run on the \"router.example.net\" node\nndnpingserver /example/server\n\n# Run on the first node\nndnping /example/server\n</code></pre> <pre><code># Run on the \"router.example.net\" node\nndnd pingserver /example/server\n\n# Run on the first node\nndnd ping /example/server\n</code></pre>"},{"location":"connectivity/communication-model/","title":"NDN Communication Model","text":"<p>NDN applications communicate using Interest-Data packet exchanges. The process of such an exchange can be summarized as follows.</p> <ol> <li>An application that desires a piece of data sends an Interest packet.      The Interest packet contains the name of the data being requested.</li> <li>The network forwards the Interest packet to the node(s) having a copy of the data.</li> <li>On receiving the Interest packet, a node may reply with a matching Data packet.</li> <li>The network the forwards this Data packet back to the requesting application.</li> </ol> <p>The pull-based data model</p> <p>Most applications today are based on the pull-based request-response data models, such as when using any HTTP-based protocol. Search a data model is an inherent conflict with the TCP/IP host-centric architecture, which is designed to push data to endpoints. NDN makes the pull based data centric model a first class citizen at the network layer. It is important to keep this key difference in mind when building NDN applications.</p> <p>Types of Applications</p> <p>Applications that send Interests to fetch data packets are called \"consumers\". Likewise, applications that serve Data in response to Interests are called \"producers\". An application may act as both a consumer and a producer simultaneously.</p>"},{"location":"connectivity/communication-model/#consumers","title":"Consumers","text":"<p>Consumers are applications that send Interest packets to fetch data. The Interest packet contains the name of the data being requested along with any optional selectors. The following snippet illustrates how to send an Interest packet and get back the corresponding Data.</p> <p>For this example to work, you must first run the producer from the next part.</p> ndn-cxxpython-ndnNDNts <pre><code>#include &lt;iostream&gt;\n#include &lt;ndn-cxx/face.hpp&gt;\n\nint main(int argc, char** argv)\n{\n    // Create an Interest packet\n    ndn::Interest interest(\"/edu/ucla/cs/118/notes\");\n\n    // Connect to the local forwarder over a Unix socket\n    ndn::Face face;\n\n    // Send the Interest packet and get back the Data packet\n    face.expressInterest(interest,\n                        [](const ndn::Interest&amp;, const ndn::Data&amp; data) {\n                            // Received a Data packet reply\n                            std::cout &lt;&lt; data &lt;&lt; std::endl;\n                        },\n                        [](const ndn::Interest&amp;, const ndn::lp::Nack&amp; nack) {\n                            // Received a Nack (negative acknowledgement)\n                            std::cout &lt;&lt; \"Nack received: \" &lt;&lt; nack.getReason() &lt;&lt; std::endl;\n                        },\n                        [](const ndn::Interest&amp;) {\n                            // The Interest has timed out\n                            std::cout &lt;&lt; \"Timeout\" &lt;&lt; std::endl;\n                        });\n\n    // Start face processing loop\n    face.processEvents();\n}\n</code></pre> <pre><code>from ndn.app import NDNApp\nfrom ndn.encoding import Name\n\n# Connect to the local forwarder over a Unix socket\napp = NDNApp()\n\nasync def main():\n    try:\n        data_name, meta_info, content = await app.express_interest(\"/edu/ucla/cs/118/notes\")\n\n        # Received a Data packet\n        print(f'Received Data Name: {Name.to_str(data_name)}')\n        print(meta_info)\n        print(bytes(content) if content else None)\n\n    except InterestNack as e:\n        # Received a Nack (negative acknowledgement)\n        print(f'Nacked with reason={e.reason}')\n    except InterestTimeout:\n        # The Interest has timed out\n        print(f'Timeout')\n    except InterestCanceled:\n        # Connection to the local NDN forwarder is broken\n        print(f'Canceled')\n    except ValidationFailure:\n        # Security validation failed for the data\n        print(f'Data failed to validate')\n\n    finally:\n        # Disconnect from the local forwarder\n        app.shutdown()\n\nif __name__ == '__main__':\n    app.run_forever(after_start=main())\n</code></pre> <pre><code>import { Interest } from '@ndn/packet';\nimport { WsTransport } from '@ndn/ws-transport';\nimport { consume } from '@ndn/endpoint';\n\n// Code running in the browser cannot connect to a local Unix socket.\n// In this example, we connect to a remote NFD instance, running as\n// a part of the global NDN testbed.\nconst uplink = await WsTransport.createFace({}, \"wss://suns.cs.ucla.edu/ws/\");\nconsole.log(`Connected to NFD at ${uplink.remoteAddress}`);\n\n// Create an Interest packet\nconst interest = new Interest(`/ndn/edu/arizona/ping/NDNts/${Date.now()}`);\n\n// Send the Interest packet and wait for the Data packet\ntry {\n    const data = await consume(interest);\n    console.log(`Received data with name [${data.name}]`);\n} catch (err: any) {\n    console.warn(err);\n}\n\n// Disconnect from the remote NFD instance\nuplink.close();\n</code></pre>"},{"location":"connectivity/communication-model/#producers","title":"Producers","text":"<p>To serve data to other applications, a producer must register a name prefix with the network.</p> <ol> <li>The producer sends a registration request to the network carrying a name prefix.</li> <li>A route to the prefix is registered at the local forwarder, and may be propagated to other forwarders in the network.</li> <li>The producer is notified of the successful registration.</li> <li>Any Interest packets matching the prefix may now be forwarded to the producer.</li> </ol> <p>The following snippet illustrates how to serve data by registering a name prefix route at the local forwarder. Make sure to start NFD on your development machine before running this example.</p> ndn-cxxpython-ndnNDNts <pre><code>#include &lt;iostream&gt;\n#include &lt;ndn-cxx/face.hpp&gt;\n#include &lt;ndn-cxx/security/key-chain.hpp&gt;\n\nint main(int argc, char** argv)\n{\n    // Connect to the local forwarder over a Unix socket\n    ndn::Face face;\n\n    // Connect to the local KeyChain to sign Data packets\n    // Note: Security is not optional in NDN\n    ndn::KeyChain keychain;\n\n    // Register a prefix with the local forwarder\n    face.setInterestFilter(\"/edu/ucla/cs/118/notes\",\n        [&amp;face, &amp;keychain](const ndn::InterestFilter&amp;, const ndn::Interest&amp; interest) {\n            std::cout &lt;&lt; \"Received Interest packet for \" &lt;&lt; interest.getName() &lt;&lt; std::endl;\n\n            // Create a Data packet with the same name as the Interest\n            ndn::Data data(interest.getName());\n\n            // Set the Data packet's content to \"Hello, World!\"\n            data.setContent(ndn::make_span(reinterpret_cast&lt;const uint8_t*&gt;(\"Hello, NDN!\"), 11));\n\n            // Sign the Data packet with default identity\n            keychain.sign(data);\n\n            // Return the Data packet to the network\n            face.put(data);\n        },\n\n        // Register prefix failure handler -- optional\n        nullptr,\n\n        // Register prefix failure handler\n        [](const ndn::Name&amp; prefix, const std::string&amp; reason) {\n            std::cout &lt;&lt; \"Route registration failed\" &lt;&lt; std::endl;\n        });\n\n    // Start face processing loop\n    face.processEvents();\n}\n</code></pre> <pre><code>from typing import Optional\nfrom ndn.app import NDNApp\nfrom ndn.encoding import Name, InterestParam, BinaryStr, FormalName\n\n# Connect to the local forwarder over a Unix socket\napp = NDNApp()\n\n# Register a prefix, and call on_interest when a matching Interest is received\n@app.route('/edu/ucla/cs/118/notes')\ndef on_interest(name: FormalName, param: InterestParam, _app_param: Optional[BinaryStr]):\n    print(f'Received Interest packet for {Name.to_str(name)}')\n\n    # Create the content bytes for the Data packet\n    content = \"Hello, NDN!\".encode()\n\n    # Sign and send the Data packet back to the network\n    app.put_data(name, content=content, freshness_period=10000)\n\nif __name__ == '__main__':\n    app.run_forever()\n</code></pre> <pre><code>import { Data, digestSigning } from '@ndn/packet';\nimport { WsTransport } from '@ndn/ws-transport';\nimport { produce } from '@ndn/endpoint';\nimport { toUtf8 } from '@ndn/util';\n\n// Code running in the browser cannot connect to a local Unix socket.\n// In this example, we connect to a remote NFD instance, running as\n// a part of the global NDN testbed.\nconst uplink = await WsTransport.createFace({}, \"wss://suns.cs.ucla.edu/ws/\");\nconsole.log(`Connected to NFD at ${uplink.remoteAddress}`);\n\n// Start one producer\nconst myProducer = produce('/edu/ucla/cs/118/notes', async (interest) =&gt; {\n    console.log(`Received Interest packet for ${interest.name.toString()}`);\n    // Create the content bytes for the Data packet\n    const content = toUtf8(\"Hello, NDN!\");\n    // Sign and send the Data packet back to the network\n    const data = new Data(interest.name, Data.FreshnessPeriod(10000), content);\n    await digestSigning.sign(data);\n    return data;\n});\n</code></pre>"},{"location":"connectivity/forwarding/","title":"NDN Forwarding Plane","text":"<p>NDN uses a stateful forwarding plane<sup>1</sup> that maintains several tables at forwarders. This is in contrast to the stateless forwarding plane of IP, which does not maintain any per-packet state. The stateful forwarding plane of NDN enables Data multicast and caching, along with other features such as privacy, loop detection, network-layer congestion control<sup>2</sup> and DoS protection<sup>3</sup>.</p> <p>Each instance of NFD in an NDN network maintains several tables. Some of these tables store per-packet state, thus making the forwarding plane stateful. The most important of these tables are described briefly in the following sections.</p> <p>Further Reading</p> <p>If you are interested in the implementation details of NFD, please refer to the NFD Developer Guide.</p>"},{"location":"connectivity/forwarding/#forwarding-information-base","title":"Forwarding Information Base","text":"<p>The FIB is a forwarding table similar to the one found in IP routers, which maps name prefixes to outgoing faces. It is used by NFD to forward Interest packets. Each entry in the FIB contains the following information.</p> <ul> <li>A name prefix.</li> <li>A set of next hops (outgoing faces).</li> <li>The cost of each next hop face.</li> </ul> <p>When NFD receives an Interest which must be forwarded, it looks up the FIB for the longest matching prefix. If a matching entry is found, the Interest may be forwarded to one or more faces specified in the entry. The exact decision of which face(s) to forward the Interest on is made by the strategy matching the prefix, as described in the next section.</p>"},{"location":"connectivity/forwarding/#strategy-table","title":"Strategy Table","text":"<p>The strategy table is used by NFD to decide which strategy to use for forwarding a given Interest. Each entry in the strategy table contains the following information.</p> <ul> <li>A name prefix.</li> <li>The name of the strategy to use for forwarding Interests matching the prefix.</li> </ul> <p>When NFD receives an Interest which must be forwarded, it looks up the strategy table for the longest matching prefix. The matching strategy is then used to decide which face(s) to forward the Interest on.</p> <p>Some examples of strategies are,</p> <ul> <li>Best route: Use the next hop with the lowest cost.</li> <li>Multicast: Forward the Interest to all next hops.</li> <li>ASF: Use the Adaptive Smoothed RTT-based Forwarding (ASF) algorithm<sup>4</sup>.</li> </ul>"},{"location":"connectivity/forwarding/#pending-interest-table","title":"Pending Interest Table","text":"<p>The PIT is the most important table in the forwarding plane, and it provides the basic support for the pull model of communication in NDN.</p> <p>When NFD receives an Interest, it stores a PIT entry in this table. Each PIT entry contains the following information.</p> <ul> <li>The name of the Interest along with any selectors.</li> <li>The incoming face on which the Interest was received (in-record).</li> <li>The outgoing face(s) on which the Interest was forwarded (out-record).</li> <li>The time at which the Interest will expire (lifetime).</li> </ul> <p>On receiving a Data packet, NFD performs the following steps.</p> <ul> <li>Looks up the PIT for an entry matching the Data packet.</li> <li>If such an entry is found, the Data packet is forwarded on the incoming face     of the PIT entry, and the PIT entry is removed from the table.</li> <li>If no matching PIT entry is found, the Data packet is dropped.</li> </ul> <p>The PIT entry is also dropped if the Interest times out before a matching Data packet is received.</p> <p>One-Interest One-Data</p> <p>A fundamental principle of NDN is that one outgoing Interest can bring back at most one Data packet. This is enforced by the PIT, since the PIT entry is removed from the table as soon as a matching Data packet is received and forwarded to the incoming face.</p> <p>Breadcrumb Trail</p> <p>In an NDN network containing multiple forwarders, PIT entries for an Interest serve as a breadcrumb trail that the Data packet follows back to the consumer. As a result, no source address is required in the Interest packet for sending the Data packet back to the consumer.</p> <p>Implementation of PIT</p> <p>For efficiency, forwarders may implement the PIT using tree-based data structures or hash tables. The entry expiration is typically implemented using priority queues.</p>"},{"location":"connectivity/forwarding/#data-multicast","title":"Data Multicast","text":"<p>The per-packet statefulness of the PIT directly enables Data multicast by allowing a single Data packet to be forwarded to multiple consumers that have expressed an Interest in the same data.</p> <p>When NFD receives an Interest, it first looks up the PIT for an entry matching the Interest. If such an entry is found, the Interest is aggregated with the existing entry, by appending an in-record to the entry for the incoming face of the new Interest. The Interest is then not forwarded further.</p> <p>When a matching Data packet is received, it is forwarded on all the incoming faces of the PIT entry. As a result, multiple Interests are satisfied with a single Data packet, thus realizing Data multicast.</p> <p>Multicast and Interest Selectors</p> <p>Interests can generally be aggregated only if they have the same name and selectors. For instance, two Interests having the same name but different values for the <code>MustBeFresh</code> selector cannot be aggregated, since they are potentially requesting different Data packets.</p>"},{"location":"connectivity/forwarding/#consumer-privacy","title":"Consumer Privacy","text":"<p>Since the PIT stores the incoming face of each Interest, the outgoing Interest does not need to contain any information about the incoming face. This enables consumer privacy in NDN, by ensuring that Interest packets cannot be used to identify the original sender.</p>"},{"location":"connectivity/forwarding/#loop-detection","title":"Loop Detection","text":"<p>The PIT also lets NFD detect and prevent looping Interests. Each Interest in NDN carries a randomly generated nonce, which is stored in the PIT entry along with the Interest name. When NFD receives an Interest, it first looks up the PIT for an entry matching the Interest. If such an entry is found including a matching nonce, then the incoming Interest is dropped.</p> <p>Longer Loops</p> <p>While the PIT prevents some types of looping Interests, it fails to detect longer loops, since an Interest may be satisfied by a Data packet before it loops back to the same forwarder. To detect such looping Interests, NFD uses a separate table called the Dead Nonce List, which stores nonces of recently satisfied Interests.</p>"},{"location":"connectivity/forwarding/#content-store","title":"Content Store","text":"<p>The Content Store is a cache of Data packets, which is used by NFD to satisfy Interests. When NFD receives an Interest, it first looks up the Content Store for a matching Data packet before looking up the FIB and Strategy Tables. If a matching Data packet is found, it is directly used to satisfy the Interest, and the Interest is not forwarded further.</p> <p>The Content Store is a key component of NDN, since it enables Data caching at the network layer. As a result, NDN supports both synchronous and asynchronous multicast of Data packets.</p> <p>Data Freshness</p> <p>NDN Data packets carry a <code>FreshnessPeriod</code>, which specifies the time in milliseconds for which the data is fresh. A Data packet cached earlier than its freshness period is considered \"non-fresh\", and cannot be used to satisfy Interests with the <code>MustBeFresh</code> selector.</p> <ol> <li> <p>Yi, C. et al. 2013. A case for stateful forwarding plane. Computer Communications. 36, 7 (2013), 779\u2013791.\u00a0\u21a9</p> </li> <li> <p>Song, S. and Zhang, L. 2022. Effective NDN congestion control based on queue size feedback. Proceedings of the 9th ACM conference on information-centric networking (New York, NY, USA, 2022), 11\u201321.\u00a0\u21a9</p> </li> <li> <p>Gasti, P. et al. 2013. DoS and DDoS in named data networking. 2013 22nd international conference on computer communication and networks (ICCCN) (2013), 1\u20137.\u00a0\u21a9</p> </li> <li> <p>Lehman, V. et al. 2016. An experimental investigation of hyperbolic routing with a smart forwarding plane in NDN. 2016 IEEE/ACM 24th international symposium on quality of service (IWQoS) (2016), 1\u201310.\u00a0\u21a9</p> </li> </ol>"},{"location":"connectivity/packet-format/","title":"NDN Packet Format","text":"<p>At a high level, NDN defines two distinct types of network packets.</p> <ul> <li>Interest packets are used to request data from the network. The most important component of an Interest packet is the name of the data being requested. An Interest may contain additional parameters such as a lifetime or hop limit, which are referred to as selectors.</li> <li>Data packets carry the actual data being requested, along with the name of the Data and a cryptographic signature. On receiving an Interest packet, nodes in the network may respond with a Data matching the name in the Interest.</li> </ul> <p>How are NDN packets used?</p> <p>Interest and Data packets are used in a request-response fashion. An NDN application sends an Interest packet to request data from the network, and receives a single Data packet in response.</p> <p>The following example illustrates the basic structure of Interest and Data packets.</p> <pre><code>classDiagram\n  Interest &lt;|-- Data\n  class Interest{\n    Name = /edu/ucla/cs/118/notes\n    Lifetime = 5000 ms\n  }\n  class Data{\n    Name = /edu/ucla/cs/118/notes\n    Content = \"Hello, NDN!\"\n    Signature = 3046022100e773b\n  }</code></pre> <p><code>CanBePrefix</code> Interest Selector</p> <p>In this example, the name of the Interest and Data packets is an exact match. If the <code>CanBePrefix</code> selector is specified on the Interest, the name of a matching Data packet may be longer than the name of the Interest packet, as long as it has the name of the Interest as a prefix.</p>"},{"location":"connectivity/packet-format/#tlv-encoding","title":"TLV Encoding","text":"<p>On the wire, NDN packets are represented using the Type-Length-Value (NDN TLV<sup>1</sup>) encoding scheme. TLV is a highly efficient binary encoding scheme that supports variable length fields and nested structures.</p> <p>Each field in the packet is encoded as a TLV element, which consists of a type, length, and value. The type and length fields are encoded as variable length integers, and the value field is encoded as a sequence of bytes (which in turn may be another TLV block). Interest and Data packets themselves are also encoded as TLV elements.</p> <p>The following example illustrates the TLV encoding of the Interest and Data packets shown above. The type of the block is specified first (in red, hover for numeric), followed by the length (in blue) and the value.</p> <p>Encoding of Names</p> <p>NDN names are hierarchical and are encoded as a list of components. Each component is treated as an opaque binary value by the network, and may contain any sequence of bytes with no restrictions. For readability, names may be represented using the NDN URI Scheme using slashes as delimiters between components.</p> <p>Packet Format Specification</p> <p>The formal specification for Interest and Data packets and TLV encoding can be accessed here.</p>"},{"location":"connectivity/packet-format/#library-functions","title":"Library Functions","text":"<p>This section describes how to encode Interest and Data packets using some of the NDN client libraries. The next page will describe how to use the libraries to send and receive the packets.</p> ndn-cxxpython-ndnNDNts <pre><code>#include &lt;ndn-cxx/face.hpp&gt;\n\nint main(int argc, char** argv)\n{\n    // Create an NDN Name from a URI string\n    ndn::Name name(\"/edu/ucla/cs/118/notes\");\n\n    // Create an Interest packet with this name\n    ndn::Interest interest(name);\n\n    // Set the Interest packet's InterestLifetime to 5 seconds\n    interest.setInterestLifetime(ndn::time::seconds(5));\n\n    // Create a Data packet with the same name\n    ndn::Data data(name);\n\n    // Set the Data packet's content to \"Hello, NDN!\"\n    data.setContent(ndn::make_span(reinterpret_cast&lt;const uint8_t*&gt;(\"Hello, NDN!\"), 11));\n}\n</code></pre> <pre><code>import ndn.encoding as enc\nimport ndn.security as sec\n\n#  Create an Interest packet with its NDN name from a URI string\ninterest_wire = enc.make_interest(\n    enc.Name.from_str('/edu/ucla/cs/118/notes'),\n    # Set the Interest packet's InterestLifetime to 5 seconds\n    enc.InterestParam(lifetime=5000),\n)\nprint(interest_wire.hex())\n# In python-ndn you do not have to encode the Interest manually.\n# NDNApp's express function provides a more flexible API to send an Interest directly.\n\n# Create a SHA256 digest signer\ndigest_signer = sec.DigestSha256Signer()\n# Create a Data packet with the same name\ndata_wire = enc.make_data(\n    # String can be directly used as Name in most cases\n    name='/edu/ucla/cs/118/notes',\n    # Set the Interest packet's FreshnessPeriod to 10 seconds\n    meta_info=enc.MetaInfo(freshness_period=10000),\n    # Set the Data packet's content to \"Hello, NDN!\"\n    content=b'Hello, NDN!',\n    signer=digest_signer\n)\nprint(data_wire.hex())\n</code></pre> <pre><code>import { Name, Interest, Data } from '@ndn/packet';\nimport { toUtf8 } from '@ndn/util';\n\n// Create an NDN name from a URI string\nconst name = new Name('/edu/ucla/cs/118/notes');\n\n// Create an Interest packet with this name\nconst interest = new Interest(name);\n\n// Set the Interest packet's InterestLifetime to 5 seconds\ninterest.lifetime = 5000;\n\n// Create a Data packet with the same name\nconst data = new Data(name);\n\n// Set the Data packet's content to \"Hello, NDN!\"\ndata.content = toUtf8('Hello, NDN!');\n</code></pre> <ol> <li> <p>Ma, X. et al. 2022. A type-theoretic model on NDN-TLV encoding. Proceedings of the 9th ACM conference on information-centric networking (New York, NY, USA, 2022), 91\u2013102.\u00a0\u21a9</p> </li> </ol>"},{"location":"connectivity/routing/","title":"Routing","text":"<p>This page is under construction.</p>"},{"location":"connectivity/testbed/","title":"NDN Research Testbed","text":"<p>This page is under construction.</p> <p>The Global NDN research testbed is a shared resource created for research purposes, that include software routers at several participating institutions, application host nodes, and other devices. The testbed is used for research and development of NDN software, and for experiments that require a shared NDN infrastructure. It is not intended for production use.</p> <p>Connecting NFD to the Testbed</p> <p>To connect your local NFD to the testbed, use the <code>ndn-autoconfig</code> tool. This tool uses the Find-Closest-Hub (FCH) service to find the closest testbed node, and creates a face from your local NFD to that node. It also configures the local NFD to use the testbed as a default route for Interests that do not match any local routes.</p> <pre><code>nfd-start               # start local NFD\nndn-autoconfig          # connect to the testbed\nndnping /ndn/edu/ucla   # test the connection (optional)\n</code></pre>"},{"location":"connectivity/testbed/#obtaining-a-testbed-certificate","title":"Obtaining a testbed certificate","text":"<p>The easiest way to obtain a testbed certificate is to use the NDNCERT client. To begin ensure that you have installed NFD and NDNCERT.</p> <p>You can now request a certificate from the testbed certificate authority.</p> <pre><code># Start and connect your local NFD to the testbed\nnfd-start\nndn-autoconfig\n\n# Configure the NDNCERT client using the default configuration (if required)\nsudo cp /usr/local/etc/ndncert/client.conf.sample /usr/local/etc/ndncert/client.conf\n\n# Request a testbed certificate\nndncert-client\n</code></pre> <p>You will be prompted to select the CA. Choose index <code>0</code> to probe the NDN Testbed root CA. <pre><code>Step 1: CA SELECTION\n&gt; Index: 0\n&gt;&gt; CA prefix:/ndn\n&gt;&gt; Introduction:\nPlease type in the CA's index that you want to apply or type in NONE\nif your expected CA is not in the list:\n</code></pre></p> <p>The client will then prompt you to provide your email address for name assignment. If you use an email address from a domain that is part of the testbed, the client will redirect your request to the appropriate Site CA. Otherwise, you will be issued a certificate from the Testbed Root CA. <pre><code>Step 2: Please provide information for name assignment\nPlease input: email\n</code></pre></p> <p>Next, provide the expected validity period for the certificate, which should be less than the maximum allowed by the CA. <pre><code>Step 3: Please type in your expected validity period of your certificate.\nType the number of hours (168 for week, 730 for month, 8760 for year).\nThe CA may reject your application if your expected period is too long.\nThe maximum validity period allowed by this CA is 360 hours.\n</code></pre></p> <p>(Optional) If local keychain already has a key with same name, you need to select whether you want to certify an existing key, or creating a new key under the same name and certify it. <pre><code>Step 4: KEY SELECTION\nIndex: 0\n&gt;&gt; Key Name:  +-&gt;* /ndn/edu/ucla/alice/KEY/%BE%B1cqk%25%3D%20\nPlease type in the key's index that you want to certify\nor type in NEW if you want to certify a new key:\n</code></pre></p> <p>The CA will now send a verification code to your email address (this code may sometimes be sent to your spam folder). Enter the code to complete the certificate request. <pre><code>Step 4: Please provide parameters used for Identity Verification Challenge\nPlease input your verification code\n</code></pre></p> <p>If verification succeeds, the certificate will be issued and installed into your local ndnsec keychain.</p> <pre><code># View all existing certificates\nndnsec list -c\n</code></pre>"},{"location":"connectivity/testbed/#prefix-announcements","title":"Prefix announcements","text":"<p>Once you have obtained a testbed certificate as described above, you can announce your data prefixes to testbed routing (NLSR). This allows other applications connected to the testbed to send Interests to your application.</p> <p>A simple way to announce your prefix during debugging is to use the ndn6-tools package.</p> <pre><code># Get the name of the certificate issued by NDNCERT and set it to default\n# Certificates issed by NDNCERT are indicated as such in the name\nndnsec list -c\nndnsec set-default -c /ndn/edu/ucla/alice/KEY/%5C7%02%D6%A2%1E%CFo/NDNCERT/v=1709685136466\n\n# Dump the newly obtained certificate to a file using ndnsec\nndnsec cert-dump /ndn/edu/ucla/alice/KEY/%5C7%02%D6%A2%1E%CFo/NDNCERT/v=1709685136466 &gt; testbed.cert\n\n# Make sure this certificate is available to consumers (NLSR)\nndn6-serve-certs testbed.cert\n\n# Find the remote of the face connecting to the testbed\n# e.g. udp4://131.179.196.48:6363\nnfdc face list\n\n# Send a prefix announcement to the testbed\nndn6-register-prefix-remote \\\n    -f udp4://131.179.196.48:6363 \\\n    -p /alice/test \\\n    -i /ndn/edu/ucla/alice\n\n# If the above command returns a 200 status code, the prefix has been successfully announced\n</code></pre> <p>You can now register prefixes under the <code>/alice/test</code> namespace with your local NFD and be reachable from other nodes connected to the testbed.</p>"},{"location":"connectivity/testbed/#connection-from-application","title":"Connection from application","text":"<p>When a local NFD is not available, for example in web-based applications, the application may directly connect to a testbed node. The FCH service allows applications to find the geographically closest testbed node using the client's IP address. No security configuration is required to send Interests to the testbed, as illustrated in the following example.</p> NDNts <pre><code>import { connectToNetwork } from \"@ndn/autoconfig\";\nimport { consume } from \"@ndn/endpoint\";\nimport { Interest } from \"@ndn/packet\";\n\n// Connect the default forwarder instance to the closest NDN testbed node using the FCH service\nawait connectToNetwork({\n    fallback: [\"titan.cs.memphis.edu\"],  // optional fallback list\n    connectTimeout: 3000,                // optional connection timeout\n});\n\n// Send an Interest to a ping server on the testbed\nconst interest = new Interest(`/ndn/edu/memphis/ping/1234`);\nconst data = await consume(interest); // wait for echo\n</code></pre>"},{"location":"security/introduction/","title":"NDN Security","text":"<p>Security is baked into the core of NDN, and is a fundamental part of the architecture. NDN networks and applications utilizes a data-centric name-based security and trust model, where all data is signed by the producer of the data.</p> <p>Each subsection below describes one aspect of the NDN security model.</p> <ul> <li>Trust Model - How does NDN define data trustworthiness?</li> <li>Signatures - How is the trust model implemented with digital signatures?</li> </ul>"},{"location":"security/signatures/","title":"Signatures in NDN","text":"<p>This page is under construction.</p> <p>In NDN, all data is digitally signed by the original data producer. The signature guarantees the authenticity and integrity of a given block of data, because the signature can only be generated by the original producer, and becomes invalid if the data is modified. These signatures stay with the data both during transit and at rest, and thus guarantee the security of the data at all times.</p>"},{"location":"security/signatures/#signing-data","title":"Signing Data","text":"<p>Digital signing is done by a pair of asymmetric keys, which consists of a private key and a public key. The private key is known only by the producer, used to generate signatures. Anyone who knows the public key can verify the signature.</p> python-ndnNDNts <pre><code>import ndn.encoding as enc\nimport ndn.security as sec\nfrom Cryptodome.PublicKey import ECC\n\n# Generate key pairs (Recommend 'P-256' for ECDSA and 'ed25519' for EdDSA)\npriv_key = ECC.generate(curve='ed25519')\npub_key = priv_key.public_key()\n# Create a signer\nsigner = sec.Ed25519Signer('/edu/ucla/xinyu.ma', priv_key.export_key(format='DER'))\n# Sign a data with it\ndata_wire = enc.make_data(\n    # String can be directly used as Name in most cases\n    name='/edu/ucla/cs/118/notes',\n    # Set the Interest packet's FreshnessPeriod to 10 seconds\n    meta_info=enc.MetaInfo(freshness_period=10000),\n    # Set the Data packet's content to \"Hello, NDN!\"\n    content=b'Hello, NDN!',\n    signer=signer\n)\nprint('Data:', data_wire.hex())\n\n# Export public keys\npub_key_bits = pub_key.export_key(format='DER')\nprint('Public Key bits:', pub_key_bits.hex())\n# Can be imported by: ECC.import_key(pub_key_bits)\n\n# Then verify the Data packet using it\n_, _, _, sig_ptrs = enc.parse_data(data_wire)\nif sec.verify_ed25519(pub_key, sig_ptrs):\n    print('Data verified')\nelse:\n    print('Data not verified')\n</code></pre> <pre><code>import { Data, Name } from '@ndn/packet';\nimport { Decoder, Encoder } from '@ndn/tlv';\nimport { toHex, toUtf8 } from '@ndn/util';\nimport { Ed25519, generateSigningKey } from '@ndn/keychain';\n\n// Generate key pairs (Recommend ECDSA and Ed25519 for EdDSA)\nconst identityName = new Name('/edu/ucla/xinyu.ma');\nconst [signer, verifier] = await generateSigningKey(identityName, Ed25519);\n// Sign a Data with it\nconst data = new Data(\n  new Name('/edu/ucla/cs/118/notes'),\n  Data.FreshnessPeriod(10000),\n  toUtf8('Hello, NDN!'));\nawait signer.sign(data);\n// Print the Data wire\nconst wire = Encoder.encode(data);\nconsole.log('Data:', toHex(wire));\n\n// Export public keys\nconst publicKeyBits = verifier.spki!;\nconsole.log('Public Key bits:', toHex(publicKeyBits));\n// Importing a public key in NDNts is very complicated\n// so I recommend to use a certificate instead.\n// I will show you how to do it later.\n\n// Then verify the Data packet using it\nconst decodedData = Decoder.decode(wire, Data); // Be the same as `data`\ntry {\n  await verifier.verify(decodedData);\n  console.log('Data verified');\n} catch {\n  console.log('Data not verified');\n}\n</code></pre> <p>In a system, security is more than cryptographically verifying the signature. For example, we also need to</p> <ul> <li>Securely obtain the public key of the producer.<ul> <li>A signed piece of data containing the pubic key is called a certificate.</li> </ul> </li> <li>Associate the producer with a member (human or process) in the system.</li> <li>Make sure the member is allowed to sign the data.</li> </ul> <p>These tasks can be roughly classified into four aspects:</p> <ul> <li>Bootstrapping: to enroll a new member into an application. Make sure that the new member learns necessary security information to recognize others, and the other members are able to securely recognize new member.</li> <li>Key Management: to manage the membership and certificates, including certification revocation, renewal, and other operations.</li> <li>Authentication: to verify a piece of data is produced by claimed producer and not manipulated by an impersonator.     This includes cryptographically verifying the signature.</li> <li>Authorization: a piece of data is produced by an intended producer, and accessed by an intended consumer.     This includes discarding of data whose producers are not allowed to produce, and encrypting data so that only permitted consumers can decrypt.</li> </ul> <p>The classification described is not strict. Most work on NDN involves more than one aspects of the security.</p>"},{"location":"security/trust-model/","title":"Data-centric Trust in NDN","text":"<p>This article provides a brief overview of the data-centric trust model of NDN<sup>1</sup><sup>2</sup>.</p> <p>The key feature of NDN that enables systematic and provable data centric security is the semantic name that identifies each object. NDN applications establish trust relations directly based on data names, which eliminates the need for manually configured roles and ACLs.</p> <p>The data-centric trust model of NDN is based two components. When communicating with someone, one needs to know,</p> <ol> <li>Identity: Who am I talking to?</li> <li>Policy: What are they allowed to say?</li> </ol> <p>We describe these components in detail and explain the NDN trust model with an example.</p>"},{"location":"security/trust-model/#identity","title":"Identity","text":"<p>To enable secure communication in any network,</p> <ol> <li>Each entity must be uniquely identifiable.</li> <li>All communicating entities should be able to authenticate each other.</li> </ol> <p>In the NDN trust model, each entity is identified with a unique name. The key component of the data-centric trust model is that this name describes semantics about the entity. The structuring of NDN names can be considered to be similar to, and optionally be based on the existing DNS name hierarchy.</p> <p>An example of a semantic name hierarchy partially based on existing DNS names is shown below. The exact name hierarchy to use may depend on application semantics, as described in later sections.</p> <pre><code># Structured NDN identity name for an organization.\n/edu/ucla\n\n# A nested sub-namespace inside UCLA to represent a \"department\".\n# In this case, we encode the organizational semantics into the identity.\n/edu/ucla/cs\n/edu/ucla/remap\n\n# A sub-namespace inside a department identifying an individual person.\n/edu/ucla/cs/faculty/lixia\n/edu/ucla/cs/students/varun\n/edu/ucla/remap/faculty/jeff\n\n# A separate namespace identifying individual smart devices.\n/edu/ucla/facilities/eng6/floor-3/room-372/door\n/edu/ucla/facilities/eng6/floor-5/room-514/door\n/edu/ucla/facilities/eng6/floor-5/room-514/light/2\n</code></pre> <pre><code>flowchart TD\n    ucla --&gt; cs\n    ucla --&gt; remap\n\n    cs --&gt; f1[faculty] --&gt; lixia{{lixia}}\n    cs --&gt; students --&gt; varun{{varun}}\n    remap --&gt; f2[faculty] --&gt; jeff{{jeff}}\n\n    ucla --&gt; facilities --&gt; eng6\n    eng6 --&gt; floor-3 --&gt; room-372 --&gt; door{{door}}\n    eng6 --&gt; floor-5 --&gt; room-514 --&gt; door2{{door}}\n    room-514 --&gt; light --&gt; two{{2}}</code></pre> <p>Entities in NDN authenticate each other using heirarchical certificates. Each entity is provisioned with a private key that is certified by another entity higher up in the hierarchy. On receiving data from another entity, the consumer can authenticate the other entity using this certificate.</p> <p>Each organization and application gains full control over their trust model by having a local trust anchor and delegating authority to issue certificates. The example below shows how the certificates hierarchy may be established in the UCLA organization.</p> <pre><code># In this example, each line represents a certificate issued to an\n# entity by another entity. The notation used is `identity &lt;= issuer`\n\n# The trust anchor key is the root of all trust.\n# This certificate is self-signed and must be well-known to all entities.\n/edu/ucla &lt;= /edu/ucla\n\n# The root key is used to certify all departments.\n/edu/ucla/cs     &lt;= /edu/ucla\n/edu/ucla/remap  &lt;= /edu/ucla\n\n# Departments in turn certify all staff and students.\n/edu/ucla/cs/faculty/lixia    &lt;= /edu/ucla/cs\n/edu/ucla/cs/students/varun   &lt;= /edu/ucla/cs\n/edu/ucla/remap/faculty/jeff  &lt;= /edu/ucla/remap\n\n# Departments also certify all devices that are owned by them.\n/edu/ucla/facilities/eng6/floor-3/room-372/door     &lt;= /edu/ucla/cs\n/edu/ucla/facilities/eng6/floor-3/room-514/door     &lt;= /edu/ucla/cs\n/edu/ucla/facilities/eng6/floor-5/room-514/light/2  &lt;= /edu/ucla/cs\n</code></pre> <p>Each NDN certificate is NDN data itself, and identifies signer of the certificate using a <code>KeyLocator</code> field. As a result, consumers can directly fetch the chain of certificates needed to verify a given data till they reach a root of trust.</p> <p>In the above example, if <code>jeff</code> receives a data object <code>website</code> from <code>lixia</code>,</p> <ol> <li><code>lixia</code> signs the data with the <code>/edu/ucla/cs/faculty/lixia</code> key, received by <code>jeff</code>.</li> <li><code>jeff</code> fetches the <code>/edu/ucla/cs/faculty/lixia &lt;= /edu/ucla/cs</code> certificate using the <code>KeyLocator</code> in the data.</li> <li><code>jeff</code> verifies the signature on the data with the public key in the certificate.</li> <li><code>jeff</code> fetches the <code>/edu/ucla/cs &lt;= /edu/ucla</code> certificate using the <code>KeyLocator</code> in the certificate.</li> <li><code>jeff</code> verifies the signature on the first certificate.</li> <li><code>jeff</code> verifies the second certificate, which is signed by a known trust anchor.</li> <li>The chain of verification is now complete, and <code>jeff</code> has successfully authenticated that <code>lixia</code> originally produced the data.</li> </ol> <pre><code>flowchart TD\n    /edu/ucla --&gt;|signs| /edu/ucla/cs\n    /edu/ucla --&gt;|signs| /edu/ucla/remap\n\n    /edu/ucla/cs --&gt;|signs| varun{{/edu/ucla/cs/students/varun}}\n    /edu/ucla/cs --&gt;|signs| lixia{{/edu/ucla/cs/faculty/lixia}} --&gt;|signs| lws([/edu/ucla/cs/faculty/lixia/website])\n    /edu/ucla/remap --&gt;|signs| jeff{{/edu/ucla/remap/faculty/jeff}}\n\n    lws -. fetched by .-&gt; jeff</code></pre> <p>Identity in WebPKI</p> <p>In the traditional WebPKI trust model, the unique identity is typically provided by the DNS system, and authentication is provided by one or more \"trusted\" certificate authorities. This means, however, that all trust between communicating entities depends on the implicit trust they have in these certificate authorities, typically by virtue of having certificates pre-installed in the operating system.</p>"},{"location":"security/trust-model/#trust-policy","title":"Trust Policy","text":"<p>Once every communicating entity has an identity, consumers can know who they are talking to. However, they still need to know what the other entity can say. This information is systematically encoded in a trust policy defined by the application.</p> <p>In NDN, a trust schema defines an application or organization's trust policy using a trust language such as Light Versec<sup>3</sup>. One or more trust languages are supported by all major NDN implementations.</p> <p>The trust schema defines which producer (by name) is allowed to generate what data. Typically, the trust schema is defined hierarchically, utilizing the name semantics of the application.</p> <p>To illustrate the usage of a name-based trust policy, we utilize the same UCLA example described above. Let us assume that the following policy must be enforced by the organization.</p> <ol> <li>All CS faculty can open all doors in the Engineering 6 building.</li> <li>Everyone in the CS department can turn on lights in Engineering 6.</li> <li>All faculty in UCLA can open doors on Floor 5 in Engineering 6.</li> </ol> <p>Such a trust policy can be written as a simple NDN trust schema as described below. Note that the pseudo-sytax is very similar to Light Versec, but is described in a verbose format for ease of understanding.</p> <pre><code>// Each line below is a policy \"rule\" - a definition of who can say what.\n// The pseudo syntax is similar to Light Versec and describes:\n//\n//   #rule_name: /what/data/is/this &lt;= /who/can/say/this\n//\n// We must first define the certification hierarchy in the application.\n// We start by definining the root of trust of the organization.\n#ucla: /\"edu\"/\"ucla\"\n\n// Rules may now refer to previously defined rules.\n//\n// Here, we define the name structure of a department, and declare that it\n// must be signed by the root of trust. The #KEY component refers to NDN's\n// pre-defined certificate naming convention.\n//\n// Since `dept` is not in quotes, it refers to a wildcard name component.\n// Thus, UCLA can now sign new departments with the root key without changing\n// the organization-wide trust policy.\n#department: #ucla/dept/#KEY &lt;= #ucla/#KEY\n\n// The next rule defines name structure for students and faculty, and declares\n// that these must be signed by the department they belong to.\n//\n// In this rule, notably, since #department is used in both the rule and the\n// signer definition, the wildcard components must match during verfication.\n// This means that the `/edu/ucla/remap` key cannot sign the certificate\n// for /edu/ucla/cs/students/varun\n//\n// Note that this structure is not rigid. For example, additional rules may\n// define some rule exceptions, such as where certain faculty certificates\n// may be signed by other departments.\n#students: #department/\"students\"/name/#KEY &lt;= #department\n#faculty: #department/\"faculty\"/name/#KEY &lt;= #department\n\n// Finally we define the naming structure for devices in UCLA facilities.\n// To allow one room to have multiple lights, we define an unnamed wildcard\n// component with `_`, which can match anything.\n#room: #ucla/\"facilities\"/building/floor/room\n#door: #room/\"door\"\n#light: #room/\"light\"/_\n\n// We can now define our actual device-control trust policy.\n//\n// \"All CS faculty can open all doors in the Engineering 6 building.\"\n//\n// To define this policy, we restrict the `building` variable to a particular\n// value, and define the entities allowed to say the \"open\" command by\n// restricting the `dept` variable in the signers.\n#cs_faculty: #faculty &amp; { dept: \"cs\" }\n#policy1: #door/\"open\" &amp; { building: \"eng6\" } &lt;= #cs_faculty\n\n// \"Everyone in the CS department can turn on lights in Engineering 6.\"\n//\n// We use two wildcards for the \"cs_all\" rule, the first to allow\n// any type of person (student or faculty), and the second to allow any\n// name. There are many different ways to write the same rule in a trust\n// language, and the rule below is only representative.\n#cs_all: #department/_/_/#KEY &amp; { dept: \"cs\" }\n#policy2: #light/\"on\" &amp; { building: \"eng6\" } &lt;= #cs_all\n\n// \"All faculty in UCLA can open doors on Floor 5 in Engineering 6.\"\n//\n// Once the naming structure is well-defined, additional complex rules\n// can be easily added using the trust schema rules syntax.\n#policy3: #door/\"open\" &amp; { building: \"eng6\", floor: \"floor-5\" } &lt;= #faculty\n</code></pre> <p>Once a trust policy is defined as a trust schema, NDN client libraries can automatically enforce the policy on all received data. For example, if the schema above is installed in all devices in UCLA, a door in Engineering 6 can automatically verify if the entity sending an \"open\" command is authorized to perform this action.</p> <p>Two important features of a schematized trust policy may be noted below.</p> <ol> <li>Additional certificates can now be issued without modifying the policy. For example, new students in the CS department can be issued a certificate with the correct naming structure, and they are automatically granted access to use lights in the E6 building. Schematizing the trust policy eliminates the need to maintain complicated ACLs.</li> <li>The trust policy establishes relations directly between users and the devices, without the requirement of a trusted identity provider. This eliminates the single point of failure, and the system continues to function even when disconnected from the public internet, e.g. in ad-hoc or air-gapped scenarios.</li> </ol> <ol> <li> <p>Zhang, Z. et al. 2018. An overview of security support in named data networking. IEEE Communications Magazine. 56, 11 (2018), 62\u201368.\u00a0\u21a9</p> </li> <li> <p>Yu, T. et al. 2024. Secure web objects: Building blocks for metaverse interoperability and decentralization. 2024 IEEE international conference on metaverse computing, networking, and applications (MetaCom) (Los Alamitos, CA, USA, 2024), 25\u201333.\u00a0\u21a9</p> </li> <li> <p>Yu, T. et al. 2023. A new API in support of NDN trust schema. Proceedings of the 10th ACM conference on information-centric networking (New York, NY, USA, 2023), 46\u201354.\u00a0\u21a9</p> </li> </ol>"}]}